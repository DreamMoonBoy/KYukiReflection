@file:Suppress("UNCHECKED_CAST", "NOTHING_TO_INLINE")
package com.dream.yukireflection.factory

import com.dream.yukireflection.KYukiReflection
import com.dream.yukireflection.bean.KCurrentClass
import com.dream.yukireflection.bean.KGenericClass
import com.dream.yukireflection.build.KTypeBuild
import com.dream.yukireflection.finder.base.rules.KModifierRules
import com.dream.yukireflection.finder.classes.KClassFinder
import com.dream.yukireflection.finder.callable.KConstructorFinder
import com.dream.yukireflection.finder.callable.KFunctionFinder
import com.dream.yukireflection.finder.callable.KPropertyFinder
import com.dream.yukireflection.finder.tools.KReflectionTool
import com.dream.yukireflection.finder.type.factory.*
import com.dream.yukireflection.finder.type.factory.KConstructorConditions
import com.dream.yukireflection.finder.type.factory.KFunctionConditions
import com.dream.yukireflection.finder.type.factory.KModifierConditions
import com.dream.yukireflection.finder.type.factory.KPropertyConditions
import com.highcapable.yukireflection.bean.CurrentClass
import com.highcapable.yukireflection.bean.GenericClass
import com.highcapable.yukireflection.factory.extends
import org.jetbrains.kotlin.utils.addToStdlib.ifTrue
import java.lang.reflect.Field
import java.lang.reflect.Method
import kotlin.jvm.internal.CallableReference
import kotlin.reflect.*
import kotlin.reflect.full.*
import kotlin.reflect.jvm.*

/**
 * 将 [Class] 强行转换为 [KClass]
 *
 * @return [KClass]
 */
val <T> Class<out T>.kotlinAs get() = this.kotlin as KClass<T & Any>

/**
 * 将 [KType] 转换为 [KClass]
 *
 * -此行为将进行泛型擦除 如果KType是类似T:Number的类型此操作将返回Number 如果没有界限则为Any
 */
val KType.kotlin get() = this.jvmErasure

/**
 * 将 [KParameter] 转换为 [KClass]
 *
 * @see [KType.kotlin]
 */
val KParameter.kotlin get() = this.type.jvmErasure

/**
 * 将 [KParameter] 转换为 [KClass]
 *
 * @return Collection [KClass]
 * @see [KType.kotlin]
 */
val Collection<KParameter>.kotlin get() = this.map { it.type.jvmErasure }.toTypedArray()

/**
 * 将 [KParameter] 转换为 [KType]
 *
 * @return Collection [KType]
 * @see [KType.kotlin]
 */
val Collection<KParameter>.type get() = this.map { it.type }.toTypedArray()

/**
 * 将 [KProperty] 转换为 [KMutableProperty]
 *
 * @return [KMutableProperty]
 */
val KProperty<*>?.toMutable get() = toMutableOrNull ?: error("Converted Failed [$this]:\n KProperty<*>.toMutable Generated by KReflectionFactory")

/**
 * 将 [KProperty] 转换为 [KMutableProperty]
 *
 * 如果无法转换则返回 Null
 *
 * @return [KMutableProperty] or null
 */
val KProperty<*>?.toMutableOrNull get() = this as? KMutableProperty

/**
 * 设置此 [KProperty] 的值
 *
 * @param thisRef 此 [KProperty] 的this实例 可空
 * @param any 设置的值
 */
operator fun KProperty<*>.set(thisRef:Any? = null,any: Any?){
    val mut = toMutableOrNull

    if (mut == null)
        javaField?.set(thisRef,any)
    else
        if (thisRef != null)
            mut.setter.call(thisRef,any)
        else
            mut.setter.call(any)
}

/**
 * 获取属性 [KProperty] 的Kotlin返回类型
 *
 * 即使获取不成功也会通过签名获取
 *
 * @return KotlinClass对象实例 [KClass]
 */
val <V> KProperty<V?>.kotlin: KClass<V & Any>
    get() = try {
        returnType.jvmErasure
    } catch (e: Exception) {
        javaField?.type?.kotlin ?: javaGetter?.returnType?.kotlin
    } catch (e: Error) {
        ref.signature.let {
            it.substring(it.indexOf(")L") + ")L".length, it.lastIndex).replace("/", ".")
        }.toKClass()
    } as KClass<V & Any>

/**
 * 此 属性 [KProperty] 是否为可变属性
 *
 * @return [Boolean]
 */
val KProperty<*>.isVar: Boolean
    get() = when (this) {
        is KMutableProperty -> true
        else -> false
    }

/**
 * 获取属性/函数 [KCallable] 的Java返回类型
 *
 * 即使获取不成功也会通过签名获取
 *
 * @return JavaClass对象实例 [Class]
 */
val <V> KCallable<V>.java: Class<V>
    @JvmName("getKTypeAs") get() = try {
        returnType.jvmErasure.java
    } catch (e: Exception) {
        when (this) {
            is KProperty -> javaField?.type ?: javaGetter?.returnType
            is KFunction -> javaMethod?.returnType ?: javaConstructor?.declaringClass
            else -> throw NotImplementedError("不受支持的转换")
        }
    } catch (e: Error) {
        ref.signature.let {
            it.substring(it.indexOf(")L") + ")L".length, it.lastIndex).replace("/", ".")
        }.toKClass()
    } as Class<V>

/**
 * 获取属性/函数 [KCallable] 的kotlin具体引用信息
 *
 * 引用信息往往存在于自动生成的Kotlin类中
 *
 *     如: String::substring.apply { -- code -- }.ref // 其::的行为将在编译时为使用String::substring所在的类创建CallableReference的引用类 其包含类信息和方法签名信息等
 *
 *         String::class.function { name = "substring" }.give().ref // error:指定从KClass获取的函数并不会通过CallableReference创建并获取
 *
 * [CallableReference] 的存在为了让引用反射获取基础信息能加载更快，通过KClass获取会慢上几分，但一旦涉及复杂反射他们速度将持平
 *
 * @return [CallableReference]
 */
val KCallable<*>.ref
    get() = this as CallableReference

/**
 * 获取引用信息 [CallableReference] 的声明类
 *
 * @return [KClass]
 */
val CallableReference.declaringKotlin
    get() = this.owner as KClass<*>

/**
 * 当前 [Class] 是否是kotlin类
 *
 * @return [Boolean]
 */
val Class<*>.isKotlin: Boolean get() =  annotations.any { it.annotationClass.jvmName == Metadata::class.jvmName }

/**
 * 当前 [KClass] 的父类
 *
 * @return 父类 [KClass] 对象
 */
val KClass<*>.superclass get() = superclasses.find { !it.java.isInterface }

/**
 * 当前 [KClass] 的密封类
 *
 * @return 密封类 [KClass] 对象
 */
val KClass<*>.enclosingClass get() = this.java.enclosingClass?.kotlinAs

/**
 * 当前 [KClass] 的简易类名 未找到时通过java对象获取
 *
 * @return [String]
 */
val KClass<*>.simpleNameOrJvm: String get() = this.simpleName ?: this.java.simpleName

/**
 * 当前 [KClass] 是否是匿名类 - 来自Java
 *
 * @return [Boolean]
 */
val KClass<*>.isAnonymous get() = this.java.isAnonymousClass

/**
 * 当前 [KClass] 的完整类名 未找到时通过java对象获取
 *
 * @return [String]
 */
val KClass<*>.name: String get() = this.qualifiedName ?: this.jvmName

/**
 * 当前 [KClass] 是否有继承关系 - 父类是 [Any] 将被认为没有继承关系
 *
 * @return [Boolean]
 */
val KClass<*>.hasExtends get() = superclass != Any::class

/**
 * 当前 [KClass] 的所有接口
 *
 * @return List<[KClass]>
 */
val KClass<*>.interfaces get() = superclasses.filter { it.java.isInterface }

/**
 * 当前 [KClass] 的泛型列表
 *
 *     class A<T?,in D,L:Int?>() -> [T?,in D,L:Int?]
 *
 * 附带继承(界限)信息
 */
val KClass<*>.generics get() = typeParameters

/**
 * 当前 [KClass] 的 [KType] 表示
 *
 *     class A<T,in D,L:Int>() -> A<*,*>
 *
 * 泛型参数信息由星射代替[KTypeProjection.STAR]
 */
val KClass<*>.type get() = starProjectedType

/**
 * 当前 [KType] 是否是基本类型
 *
 * @see [KType.javaType]
 * @return [Boolean]
 */
val KType.isPrimitive get() = java.isPrimitive

/**
 * 当前 [KType] 的 [Class] 类型
 *
 * 获取保留的来源Class 如封装Int或是基本Int
 *
 * @return [Class]
 */
val KType.java get() = kotlin.java

/**
 * 当前 [KClass] 是否继承于 [other]
 *
 * 如果当前 [KClass] 就是 [other] 也会返回 true
 *
 * 如果当前 [KClass] 为 null 或 [other] 为 null 会返回 false
 * @param other 需要判断的 [KClass]
 * @return [Boolean]
 */
infix fun KClass<*>?.extends(other: KClass<*>?): Boolean {
    if (this == null || other == null) return false
    var isMatched = false

    /**
     * 查找是否存在父类
     * @param current 当前 [KClass]
     */
    fun findSuperClass(current: KClass<*>) {
        if (current == other)
            isMatched = true
        else if (current != Any::class && current.superclass != null) findSuperClass(current.superclass!!)
    }
    findSuperClass(current = this)
    return isMatched
}

/**
 * 当前 [KClass] 是否不继承于 [other]
 *
 * 此方法相当于 [extends] 的反向判断
 * @param other 需要判断的 [KClass]
 * @return [Boolean]
 */
infix fun KClass<*>?.notExtends(other: KClass<*>?) = extends(other).not()

/**
 * 当前 [KClass] 的 ClassLoader
 *
 * @return [ClassLoader]
 */
val KClass<*>.classLoader get() = this.java.classLoader!!

/**
 * 通过字符串类名转换为 [loader] 中的实体类
 * @param loader [KClass] 所在的 [ClassLoader] - 默认空 - 不填使用默认 [ClassLoader]
 * @param initialize 是否初始化 [KClass] 的静态方法块 - 默认否
 * @return [KClass]
 * @throws NoClassDefFoundError 如果找不到 [KClass] 或设置了错误的 [ClassLoader]
 */
inline fun String.toKClass(loader: ClassLoader? = null, initialize: Boolean = false) = KReflectionTool.findClassByName(name = this, loader, initialize)

/**
 * 通过字符串类名转换为 [loader] 中的实体类
 * @param loader [KClass] 所在的 [ClassLoader] - 默认空 - 不填使用默认 [ClassLoader]
 * @param initialize 是否初始化 [KClass] 的静态方法块 - 默认否
 * @return [KClass]<[T]>
 * @throws NoClassDefFoundError 如果找不到 [KClass] 或设置了错误的 [ClassLoader]
 * @throws IllegalStateException 如果 [KClass] 的类型不为 [T]
 */
@JvmName("toKClass_Generics")
inline fun <reified T> String.toKClass(loader: ClassLoader? = null, initialize: Boolean = false) =
    toKClass(loader, initialize) as? KClass<T & Any>? ?: error("Target Class type cannot cast to ${T::class.java}")

/**
 * 通过字符串类名转换为 [loader] 中的实体类
 *
 * 找不到 [KClass] 会返回 null - 不会抛出异常
 * @param loader [KClass] 所在的 [ClassLoader] - 默认空 - 不填使用默认 [ClassLoader]
 * @param initialize 是否初始化 [KClass] 的静态方法块 - 默认否
 * @return [KClass] or null
 */
inline fun String.toKClassOrNull(loader: ClassLoader? = null, initialize: Boolean = false) = runCatching { toKClass(loader, initialize) }.getOrNull()

/**
 * 通过字符串类名转换为 [loader] 中的实体类
 *
 * 找不到 [KClass] 会返回 null - 不会抛出异常
 * @param loader [KClass] 所在的 [ClassLoader] - 默认空 - 不填使用默认 [ClassLoader]
 * @param initialize 是否初始化 [KClass] 的静态方法块 - 默认否
 * @return [KClass]<[T]> or null
 */
@JvmName("toKClassOrNull_Generics")
inline fun <reified T> String.toKClassOrNull(loader: ClassLoader? = null, initialize: Boolean = false) =
    runCatching { toKClass<T>(loader, initialize) }.getOrNull()


/**
 * 通过 [T] 得到其 [KClass] 实例并转换为实体类
 * @param loader [KClass] 所在的 [ClassLoader] - 默认空 - 可不填
 * @param initialize 是否初始化 [KClass] 的静态方法块 - 如果未设置 [loader] (为 null) 时将不会生效 - 默认否
 * @return [KClass]<[T]>
 * @throws NoClassDefFoundError 如果找不到 [KClass] 或设置了错误的 [ClassLoader]
 */
inline fun <reified T> kclassOf(loader: ClassLoader? = null, initialize: Boolean = false):KClass<T & Any> =
    (loader?.let { T::class.java.name.toKClass(loader, initialize) } ?: T::class) as KClass<T & Any>

/**
 * 通过字符串类名使用指定的 [ClassLoader] 查找是否存在
 * @param loader [KClass] 所在的 [ClassLoader] - 不填使用默认 [ClassLoader]
 * @return [Boolean] 是否存在
 */
inline fun String.hasKClass(loader: ClassLoader? = null) = KReflectionTool.hasClassByName(name = this, loader)

/**
 * 查找变量是否存在
 * @param initiate 方法体
 * @return [Boolean] 是否存在
 */
inline fun KClass<*>.hasProperty(initiate: KPropertyConditions) = property(initiate).ignored().isNoSuch.not()

/**
 * 查找方法是否存在
 * @param initiate 方法体
 * @return [Boolean] 是否存在
 */
inline fun KClass<*>.hasFunction(initiate: KFunctionConditions) = function(initiate).ignored().isNoSuch.not()

/**
 * 查找构造方法是否存在
 * @param initiate 方法体
 * @return [Boolean] 是否存在
 */
inline fun KClass<*>.hasConstructor(initiate: KConstructorConditions = { emptyParam() }) = constructor(initiate).ignored().isNoSuch.not()

/**
 * 查找 [KCallable] 中匹配的描述符
 * @param conditions 条件方法体
 * @return [Boolean] 是否存在
 */
inline fun KCallable<*>.hasModifiers(conditions: KModifierConditions) = conditions(KModifierRules.with(instance = this))

/**
 * 查找 [KClass] 中匹配的描述符
 * @param conditions 条件方法体
 * @return [Boolean] 是否存在
 */
inline fun KClass<*>.hasModifiers(conditions: KModifierConditions) = conditions(KModifierRules.with(instance = this))

/**
 * 查找并得到变量
 * @param initiate 查找方法体
 * @return [KPropertyFinder.Result]
 */
inline fun KClass<*>.property(initiate: KPropertyConditions = {}) = KPropertyFinder(classSet = this).apply(initiate).build()

/**
 * 查找并得到方法
 * @param initiate 查找方法体
 * @return [KFunctionFinder.Result]
 */
inline fun KClass<*>.function(initiate: KFunctionConditions = {}) = KFunctionFinder(classSet = this).apply(initiate).build()

/**
 * 查找并得到构造方法
 * @param initiate 查找方法体
 * @return [KConstructorFinder.Result]
 */
inline fun KClass<*>.constructor(initiate: KConstructorConditions = {}) = KConstructorFinder(classSet = this).apply(initiate).build()

/**
 * 获得当前 [KClass] 的父类中来自尖括号的泛型对象
 *
 * [KClassConditions]同来筛选来自哪个父类/父接口
 *
 * @param initiate 实例方法体
 * @return [GenericClass]
 */
inline fun KClass<*>.genericSuper(initiate: KClassConditions = {}):KGenericClass = supertypes.generic(initiate)

/**
 * 为当前 [KClass] 构建细节Type
 *
 * [KTypeBuild]构建时所需要的参数
 *
 * @param params 为此类型增加泛型参数
 * @param initiate 实例方法体
 * @return [KTypeBuild]
 */
inline fun KClass<*>.generic(vararg params:Any,initiate: KTypeBuild.() -> Unit = {}):KGenericClass = type.generic().build { params.isNotEmpty().ifTrue { param(*params) };initiate() }

/**
 * 指定并获得类型方差版本
 *
 * @param variance 类型方差 默认没有任何方差
 * @return 包含方差映射的类型
 */
inline fun KClass<*>.variance(variance:KVariance = KVariance.INVARIANT): KTypeProjection = KTypeProjection(variance,type)

/**
 * 获得当前 [KProperty] 的返回类型中来自尖括号的泛型对象
 *
 * @param initiate 实例方法体
 * @return [GenericClass]
 */
inline fun KProperty<*>.generic(initiate: KGenericClass.() -> Unit = {}):KGenericClass = returnType.generic(initiate)

/**
 * 获得当前 [KType] 的泛型操作对象
 *
 * @param initiate 实例方法体
 * @receiver [KGenericClass]
 */
inline fun KType.generic(initiate: KGenericClass.() -> Unit = {}) = KGenericClass(this).apply(initiate)

/**
 * 获得当前 [KType] 的泛型操作对象
 *
 * @param params 为此类型增加泛型参数
 * @param initiate 实例方法体
 * @receiver [KTypeBuild]
 */
inline fun KType.genericBuild(vararg params:Any,initiate: KTypeBuild.() -> Unit = {}) = generic().build { params.isNotEmpty().ifTrue { param(*params) };initiate() }

/**
 * 指定并获得类型方差版本
 *
 * @param variance 类型方差 默认没有任何方差
 * @return 包含方差映射的类型
 */
inline fun KType.variance(variance:KVariance = KVariance.INVARIANT): KTypeProjection = KTypeProjection(variance,this)

/**
 * 获得当前 [KType] 数组的泛型操作对象
 *
 * [KClassConditions]同来筛选泛型来自哪个类/接口
 *
 * @param initiate 筛选获得泛型所在的Class
 * @return [GenericClass]
 */
inline fun Collection<KType>.generic(initiate: KClassConditions = {}):KGenericClass = this.type(this.kclass(initiate).get()).generic()

/**
 * 获得当前 [KType] 数组的泛型操作对象
 *
 * [KClassConditions]同来筛选泛型来自哪个类/接口
 *
 * @param initiate 筛选获得泛型所在的Class
 * @return [GenericClass]
 */
inline fun Array<out KType>.generic(initiate: KClassConditions = {}):KGenericClass = this.type(this.kclass(initiate).get()).generic()

/**
 * 获得当前实例的类操作对象
 * @param ignored 是否开启忽略错误警告功能 - 默认否
 * @return [CurrentClass]
 */
inline fun <reified T : Any> T.currentKotlin(ignored: Boolean = false) =
    KCurrentClass(this.javaClass.kotlin, instance = this).apply { isIgnoreErrorLogs = ignored }

/**
 * 获得当前实例的类操作对象
 * @param ignored 是否开启忽略错误警告功能 - 默认否
 * @param initiate 方法体
 * @return [T]
 */
inline fun <reified T : Any> T.currentKotlin(ignored: Boolean = false, initiate: KCurrentClass.() -> Unit): T {
    currentKotlin(ignored).apply(initiate)
    return this
}

/**
 * 通过构造方法创建新实例 - 任意类型 [Any]
 * @param args 方法参数
 * @param initiate 查找方法体
 * @return [Any] or null
 */
inline fun KClass<*>.buildOf(vararg args: Any?, initiate: KConstructorConditions = { emptyParam() }) =
    constructor(initiate).get().call(*args)

/**
 * 通过构造方法创建新实例 - 指定类型 [T]
 * @param args 方法参数
 * @param initiate 查找方法体
 * @return [T] or null
 */
@JvmName(name = "buildOf_Generics")
inline fun <T> KClass<*>.buildOf(vararg args: Any?, initiate: KConstructorConditions = { emptyParam() }) =
    constructor(initiate).get().newInstance<T>(*args)

/**
 * Returns all functions and properties declared in this class.
 * Does not include members declared in supertypes.
 */
val KClass<*>.declaredPropertys: Collection<KProperty<*>>
    get() = declaredMembers.filterIsInstance<KProperty<*>>()

/**
 * 遍历当前类中的所有方法
 * @param isAccessible 是否强制设置成员为可访问类型 - 默认是
 * @param result 回调 - ([Int] 下标,[KFunction] 实例)
 */
inline fun KClass<*>.allFunctions(isAccessible: Boolean = true, result: (index: Int, function: KFunction<*>) -> Unit) =
    (if (KYukiReflection.Configs.isUseJvmObtainCallables) java.declaredMethods.asSequence().mapNotNull { it.kotlin } else declaredFunctions.asSequence()).forEachIndexed { p, it -> result(p, it.also { e -> e.isAccessible = isAccessible }) }

/**
 * 遍历当前类中的所有构造方法
 * @param isAccessible 是否强制设置成员为可访问类型 - 默认是
 * @param result 回调 - ([Int] 下标,Constructor [KFunction] 实例)
 */
inline fun KClass<*>.allConstructors(isAccessible: Boolean = true, result: (index: Int, constructor: KFunction<*>) -> Unit) =
    (if (KYukiReflection.Configs.isUseJvmObtainCallables) java.declaredConstructors.asSequence().mapNotNull { it.kotlin } else constructors.asSequence()).forEachIndexed { p, it -> result(p, it.also { e -> e.isAccessible = isAccessible }) }

/**
 * 遍历当前类中的所有变量
 * @param isAccessible 是否强制设置成员为可访问类型 - 默认是
 * @param result 回调 - ([Int] 下标,[KProperty] 实例)
 */
inline fun KClass<*>.allPropertys(isAccessible: Boolean = true, result: (index: Int, property: KProperty<*>) -> Unit) =
    (if (KYukiReflection.Configs.isUseJvmObtainCallables) java.declaredFields.asSequence().mapNotNull { it.kotlin } else declaredPropertys.asSequence()).forEachIndexed { p, it -> result(p, it.also { e -> e.isAccessible = isAccessible }) }

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_class")
inline fun Collection<KClass<*>>.kclass(initiate: KClassConditions) =
    KClassFinder(classSet = this).apply(initiate).build()

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_class")
inline fun Array<out KClass<*>>.kclass(initiate: KClassConditions) =
    KClassFinder(classSet = this.toList()).apply(initiate).build()

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_string")
inline fun Collection<String>.kclass(loader: ClassLoader? = null, initialize: Boolean = false,initiate: KClassConditions) =
    this.map { it.toKClass(loader,initialize) }.kclass(initiate)

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_string")
inline fun Array<String>.kclass(loader: ClassLoader? = null, initialize: Boolean = false,initiate: KClassConditions) =
    this.map { it.toKClass(loader,initialize) }.kclass(initiate)

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_type")
inline fun Collection<KType>.kclass(initiate: KClassConditions) =
    this.map { it.kotlin }.kclass(initiate)

/**
 * 查找并得到类
 * @param initiate 查找方法体
 * @return [KClassFinder.Result]
 */
@JvmName("kclass_type")
inline fun Array<out KType>.kclass(initiate: KClassConditions) =
    this.map { it.kotlin }.kclass(initiate)

/**
 * 通过 [KClass] 查找并得到与之一致的 [KType]
 * @param classSet 与[KType]一致的[KClass]
 * @return [KClassFinder.Result]
 */
inline fun Collection<KType>.type(classSet: KClass<*>?) = this.find { it.kotlin == classSet } ?: error("Can't find this $classSet in [$this]:\n Collection<KType>.type Generated by KReflectionFactory")

/**
 * 通过 [KClass] 查找并得到与之一致的 [KType]
 * @param classSet 与[KType]一致的[KClass]
 * @return [KClassFinder.Result]
 */
inline fun Array<out KType>.type(classSet: KClass<*>?) = this.find { it.kotlin == classSet } ?: error("Can't find this $classSet in [$this]:\n Collection<KType>.type Generated by KReflectionFactory")

/**
 * 通过 [KClass] 查找并得到与之一直的 [KType]
 * @param T 与[KType]一致的[KClass]
 * @return [KClassFinder.Result]
 */
@JvmName(name = "type_Generics")
inline fun <reified T> Collection<KType>.type() = this.find { it.kotlin == T::class } ?: error("Can't find this ${T::class} in [$this]:\n Collection<KType>.type Generated by KReflectionFactory")

/**
 * 通过 [KClass] 查找并得到与之一直的 [KType]
 * @param T 与[KType]一致的[KClass]
 * @return [KClassFinder.Result]
 */
@JvmName(name = "type_Generics")
inline fun <reified T> Array<out KType>.type() = this.find { it.kotlin == T::class } ?: error("Can't find this ${T::class} in [$this]:\n Collection<KType>.type Generated by KReflectionFactory")

/**
 * 复制自Kotlin ReflectJvmMapping文件
 *
 * 根据 [Method] 在批量 [KCallable] 中找到与之对应的Kotlin [KFunction]
 *
 * @param method Jvm [Method]
 * @return Kotlin [KFunction]
 */
inline fun Collection<KCallable<*>>.findKFunction(method: Method): KFunction<*>? {
    // As an optimization, try to search among functions with the same name first, and then among the rest of functions.
    // This is needed because a function's JVM name might be different from its Kotlin name (because of `@JvmName`, inline class mangling,
    // internal visibility, etc).
    for (callable in this) {
        if (callable is KFunction<*> && callable.name == method.name && callable.javaMethod == method) return callable
    }
    for (callable in this) {
        if (callable is KFunction<*> && callable.name != method.name && callable.javaMethod == method) return callable
    }
    return null
}

/**
 * 复制自Kotlin ReflectJvmMapping文件
 *
 * 根据 [Method] 在批量 [KCallable] 中找到与之对应的Kotlin [KProperty]
 *
 * @param field Jvm [Method]
 * @return Kotlin [KProperty]
 */
inline fun Collection<KCallable<*>>.findKProperty(field: Field): KProperty<*>? {
    for (callable in this) {
        if (callable is KProperty<*> && callable.name == field.name && callable.javaField == field) return callable
    }
    for (callable in this) {
        if (callable is KProperty<*> && callable.name != field.name && callable.javaField == field) return callable
    }
    return null
}